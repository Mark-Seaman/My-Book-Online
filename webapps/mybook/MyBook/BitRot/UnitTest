* Unit testing *                 -*-muse-*-

 * test each function
 * use a specific example
 * write a test in each line
 * 50% of code should be tests

A unit test is written to test how a function behaves in isolation.  These are typically written at
the same time that the product code is turned on.  The act of writing unit tests, encourages good
programming, by highlighting the assumptions and dependencies that a particular function has.

A typical function of four lines should have two test cases that exercise a couple of paths through
the function.  Each function should only do a single thing, so you can test a function with two test
cases.

Each test case should be a single line of code.  It should provide a specific data example that you
know the correct answer for.  For example consider the following function and test:

 def full_name(first,last): return first+' '+last

 assert(full_name('Geek','Squad')=='Geek Squad')

This test will provide a single example that guarantees one specific example of the correct
behavior.  Many people object to this simplistic test strategy, and advocate a more comprehensive
and robust strategy.

The unintentional consequence of this philosophy is that most people don't use unit tests at all.
The testing becomes too complex because the strategy requires too much effort for the value that it
returns.

Follow these simple rules to keep your testing effective:

 1. Write a test for every function.
 2. Each test should take either one or two lines of code.
 3. Run related tests each hour and all test once a day.
 4. Keep it simple, but do it every time.
 5. Fix every failing test.
